---
layout: post
title:  "Independent Component Analysis(ICA)"
date:   2019-08-5 10:50:43
categories: 机器学习
tags: 算法 降维 数据处理
---

* content
{:toc}

主要介绍了ICA的原理。




## 1、核心思想

ICA(Independent Component Analysis,独立成分分析)，希望能利用很少的先验知识将混合信息分离，变成独立分量。也可以说希望能找到事物的一种合理表示，使各分量最大地独立。

## 2、背景问题

ICA一个经典问题是鸡尾酒宴会问题。假设宴会中有n个人，他们同时说话，我们用声音接收器收集他们的声音，得到一组数据{<a href="https://www.codecogs.com/eqnedit.php?latex={x^{(i)};i=1,2,...,m}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?{x^{(i)};i=1,2,...,m}" title="{x^{(i)};i=1,2,...,m}" /></a>}，i表示采样的时间顺序。也就是我们采集了m个时刻的数据，每个时刻的数据都是n维的（有n个特征）。

这组数据的本质是n个信号源，只不过信号混合起来了。现在我们假设这n个信号源为<a href="https://www.codecogs.com/eqnedit.php?latex=s=(s_{1},s_{2},...,s_{n})^{T},s\in&space;R^{n}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?s=(s_{1},s_{2},...,s_{n})^{T},s\in&space;R^{n}" title="s=(s_{1},s_{2},...,s_{n})^{T},s\in R^{n}" /></a>，每一维都是一个人的声音，每个人的声音信号都独立。A是一个未知的混合矩阵，用来叠加信号s,这样

<a href="https://www.codecogs.com/eqnedit.php?latex=x=[x^{(1)},x^{(2)},...,x^{(m)}]=[As^{(1)},As^{(2)},...,As^{(m)}]=A\begin{bmatrix}&space;s_{1}^{(1)}&space;&&space;s_{1}^{(2)}&space;&&space;...&space;&s_{1}^{(m)}&space;\\&space;s_{2}^{(1)}&space;&&space;s_{2}^{(2)}&space;&&space;...&space;&s_{2}^{(m)}&space;\\&space;...&space;&&space;...&space;&&space;...&space;&&space;\\&space;s_{n}^{(1)}&space;&&space;s_{n}^{(2)}&space;&&space;...&space;&s_{n}^{(m)}&space;\end{bmatrix}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?x=[x^{(1)},x^{(2)},...,x^{(m)}]=[As^{(1)},As^{(2)},...,As^{(m)}]=A\begin{bmatrix}&space;s_{1}^{(1)}&space;&&space;s_{1}^{(2)}&space;&&space;...&space;&s_{1}^{(m)}&space;\\&space;s_{2}^{(1)}&space;&&space;s_{2}^{(2)}&space;&&space;...&space;&s_{2}^{(m)}&space;\\&space;...&space;&&space;...&space;&&space;...&space;&&space;\\&space;s_{n}^{(1)}&space;&&space;s_{n}^{(2)}&space;&&space;...&space;&s_{n}^{(m)}&space;\end{bmatrix}" title="x=[x^{(1)},x^{(2)},...,x^{(m)}]=[As^{(1)},As^{(2)},...,As^{(m)}]=A\begin{bmatrix} s_{1}^{(1)} & s_{1}^{(2)} & ... &s_{1}^{(m)} \\ s_{2}^{(1)} & s_{2}^{(2)} & ... &s_{2}^{(m)} \\ ... & ... & ... & \\ s_{n}^{(1)} & s_{n}^{(2)} & ... &s_{n}^{(m)} \end{bmatrix}" /></a>

x是一个矩阵，每个列向量是<a href="https://www.codecogs.com/eqnedit.php?latex=x^{(i)}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?x^{(i)}" title="x^{(i)}" /></a>，
<a href="https://www.codecogs.com/eqnedit.php?latex=x^{(i)}=As^{(i)}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?x^{(i)}=As^{(i)}" title="x^{(i)}=As^{(i)}" /></a>
，A和s都是未知的，x是收集到的混合信号，是已知的。

我们要做的是从x得到s，这个过程也叫盲源信号分离。

## 3、计算过程

令<a href="https://www.codecogs.com/eqnedit.php?latex=\omega&space;=A^{-1}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\omega&space;=A^{-1}" title="\omega =A^{-1}" /></a>，则<a href="https://www.codecogs.com/eqnedit.php?latex=s_{j}^{(i)}=\omega&space;x_{j}^{(i)}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?s_{j}^{(i)}=\omega&space;x_{j}^{(i)}" title="s_{j}^{(i)}=\omega x_{j}^{(i)}" /></a>

但是该公式中两个矩阵不确定，<a href="https://www.codecogs.com/eqnedit.php?latex=\omega" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\omega" title="\omega" /></a>和s，这样就无法得到唯一的s;还有，信号不能是高斯分布，如果是高斯分布的话，可以由不同的混合矩阵A乘上s，得到相同的x，同样无法确定S。

那如何计算呢？

### 3.1、最大似然估计

假定有一个变量s,他的概率密度函数为<a href="https://www.codecogs.com/eqnedit.php?latex=p_{s}(s)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?p_{s}(s)" title="p_{s}(s)" /></a>（若是连续则为概率密度函数，离散则为概率）。为了简化，假定s是实数，还有一个随机变量x=As,A和x都是实数。令<a href="https://www.codecogs.com/eqnedit.php?latex=p_{x}(x)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?p_{x}(x)" title="p_{x}(x)" /></a>是x的概率密度函数，那么如何求<a href="https://www.codecogs.com/eqnedit.php?latex=p_{x}(x)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?p_{x}(x)" title="p_{x}(x)" /></a>呢？

求解之前我们先看密度函数f(x)与分布函数F(x)之间的关系：

<a href="https://www.codecogs.com/eqnedit.php?latex=F_{x}(a)&space;=&space;P(x\leqslant&space;a)=\int_{-\infty&space;}^{a}f(x)dx" target="_blank"><img src="https://latex.codecogs.com/gif.latex?F_{x}(a)&space;=&space;P(x\leqslant&space;a)=\int_{-\infty&space;}^{a}f(x)dx" title="F_{x}(a) = P(x\leqslant a)=\int_{-\infty }^{a}f(x)dx" /></a>

也就是：

<a href="https://www.codecogs.com/eqnedit.php?latex=F_{x}(x)&space;=&space;P(X\leqslant&space;x)=P(As\leqslant&space;x)=P(s\leqslant&space;\omega&space;x)=F_{s}(&space;\omega&space;x)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?F_{x}(x)&space;=&space;P(X\leqslant&space;x)=P(As\leqslant&space;x)=P(s\leqslant&space;\omega&space;x)=F_{s}(&space;\omega&space;x)" title="F_{x}(x) = P(X\leqslant x)=P(As\leqslant x)=P(s\leqslant \omega x)=F_{s}( \omega x)" /></a>

又因为<a href="https://www.codecogs.com/eqnedit.php?latex=f(x)=F^{{}'}(x)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?f(x)=F^{{}'}(x)" title="f(x)=F^{{}'}(x)" /></a>，所以

<a href="https://www.codecogs.com/eqnedit.php?latex=p_{x}(x)=F_{x}^{'}(x)=F_{s}^{'}(&space;\omega&space;x)=p_{s}(&space;\omega&space;x)\left&space;|&space;\omega&space;\right&space;|" target="_blank"><img src="https://latex.codecogs.com/gif.latex?p_{x}(x)=F_{x}^{'}(x)=F_{s}^{'}(&space;\omega&space;x)=p_{s}(&space;\omega&space;x)\left&space;|&space;\omega&space;\right&space;|" title="p_{x}(x)=F_{x}^{'}(x)=F_{s}^{'}( \omega x)=p_{s}( \omega x)\left | \omega \right |" /></a>

假定每个<a href="https://www.codecogs.com/eqnedit.php?latex=s_{i}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?s_{i}" title="s_{i}" /></a>都有概率密度<a href="https://www.codecogs.com/eqnedit.php?latex=p_{s}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?p_{s}" title="p_{s}" /></a>，那么给定时刻原信号的联合分布为：

<a href="https://www.codecogs.com/eqnedit.php?latex=p(s)=\prod_{i=1}^{n}p_{s}(s_{i})" target="_blank"><img src="https://latex.codecogs.com/gif.latex?p(s)=\prod_{i=1}^{n}p_{s}(s_{i})" title="p(s)=\prod_{i=1}^{n}p_{s}(s_{i})" /></a>

也就是说，如果每个人发出的声音独立的话，由以上公式可得：

<a href="https://www.codecogs.com/eqnedit.php?latex=p(x)=p_{s}(w_{x})\left&space;|&space;w&space;\right&space;|=\left&space;|&space;w&space;\right&space;|\prod_{i=1}^{n}p_{s}(w_{i}^{T}x)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?p(x)=p_{s}(w_{x})\left&space;|&space;w&space;\right&space;|=\left&space;|&space;w&space;\right&space;|\prod_{i=1}^{n}p_{s}(w_{i}^{T}x)" title="p(x)=p_{s}(w_{x})\left | w \right |=\left | w \right |\prod_{i=1}^{n}p_{s}(w_{i}^{T}x)" /></a>

前面提到过，如果没有先验知识，我们无法求得W和s。因此我们需要知道<a href="https://www.codecogs.com/eqnedit.php?latex=p_{s}(s_{j})" target="_blank"><img src="https://latex.codecogs.com/gif.latex?p_{s}(s_{j})" title="p_{s}(s_{j})" /></a>，我们打算选取一个概率密度函数赋给s，但是我们不能选取高斯分布的密度函数。在概率论里我们知道密度函数由累计分布函数F(x)求导得到。F(x)要满足两个性质是：单调递增和在[0,1]。我们发现sigmoid函数很适合，定义域负无穷到正无穷，值域0到1，缓慢递增。我们假定s的累积分布函数符合sigmoid函数：

<a href="https://www.codecogs.com/eqnedit.php?latex=g(s)=\frac{1}{1&plus;e^{-s}}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?g(s)=\frac{1}{1&plus;e^{-s}}" title="g(s)=\frac{1}{1+e^{-s}}" /></a>

求导：

<a href="https://www.codecogs.com/eqnedit.php?latex=p_{s}(s)=g'(s)=\frac{e^{s}}{(1&plus;e^{s})^{2}}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?p_{s}(s)=g'(s)=\frac{e^{s}}{(1&plus;e^{s})^{2}}" title="p_{s}(s)=g'(s)=\frac{e^{s}}{(1+e^{s})^{2}}" /></a>

这样就只剩参数w了，其似然函数：

<a href="https://www.codecogs.com/eqnedit.php?latex=l(W)=log&space;\prod_{i=1}^{m}p(x^{(i)})=\sum_{i=1}^{m}(\sum_{j=1}^{n}log&space;g'(W_{i}^{T}x^{(i)})&plus;log\left&space;|&space;W&space;\right&space;|)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?l(W)=log&space;\prod_{i=1}^{m}p(x^{(i)})=\sum_{i=1}^{m}(\sum_{j=1}^{n}log&space;g'(W_{i}^{T}x^{(i)})&plus;log\left&space;|&space;W&space;\right&space;|)" title="l(W)=log \prod_{i=1}^{m}p(x^{(i)})=\sum_{i=1}^{m}(\sum_{j=1}^{n}log g'(W_{i}^{T}x^{(i)})+log\left | W \right |)" /></a>

其中<a href="https://www.codecogs.com/eqnedit.php?latex=\left&space;|&space;W&space;\right&space;|" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\left&space;|&space;W&space;\right&space;|" title="\left | W \right |" /></a>求导为：

<a href="https://www.codecogs.com/eqnedit.php?latex=\Delta&space;_{W}\left&space;|&space;W&space;\right&space;|=\left&space;|&space;W&space;\right&space;|(W^{-1})^{T}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\Delta&space;_{W}\left&space;|&space;W&space;\right&space;|=\left&space;|&space;W&space;\right&space;|(W^{-1})^{T}" title="\Delta _{W}\left | W \right |=\left | W \right |(W^{-1})^{T}" /></a>

<a href="https://www.codecogs.com/eqnedit.php?latex=logg'(s)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?logg'(s)" title="logg'(s)" /></a>求导为：

<a href="https://www.codecogs.com/eqnedit.php?latex=1-2g(s)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?1-2g(s)" title="1-2g(s)" /></a>




## 参考文献

https://www.cnblogs.com/Ann21/p/9505623.html

https://blog.csdn.net/sinat_37965706/article/details/71330979

https://wenku.baidu.com/view/ebb635bf9a89680203d8ce2f0066f5335a8167d6.html



